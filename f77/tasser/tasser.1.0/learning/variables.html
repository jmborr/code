<h2>The 1001 variable names</h2>

<br>(Perl <a href="sort_variables.pl">script</a> to alphabetically sort this file everytime we add a variable. Do NOT change format of the table!)
<br>
<table BORDER=1 WIDTH="100%" NOSAVE >
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ichos</strong></font></td>
	<td WIDTH="89%">integer ichos (ichos=1, or =2) switches between two different "Boltzmann" weight</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>avv</strong></font></td>
	<td WIDTH="89%">float function avv(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4) calculates dot product of relative vectors joining 1 to 2 and 3 to 4</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aax</strong></font></td>
	<td WIDTH="89%">float function aax(i) return x(i) if "i" moveable, otherwise returns ex(i)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aax</strong></font></td>
	<td WIDTH="89%">float function aay(i) return y(i) if "i" moveable, otherwise returns ey(i)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aax</strong></font></td>
	<td WIDTH="89%">float function aaz(i) return z(i) if "i" moveable, otherwise returns ez(i)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ei5</strong></font></td>
	<td WIDTH="89%">float function ei5(i,idist) is either zero or the potential associated to the distance betwen residues i-2 and i+2, ie, acops(i,d(i-2,i+2))</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ek5</strong></font></td>
	<td WIDTH="89%">float ek5 is local variable to function EHB. It reflect the probability (from PDB statistics) that the currently evaluated stretch of 5 residues  has its current distance from first to last residue.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nopp</strong></font></td>
	<td WIDTH="89%">integer nopp(ndim) is backup of nop</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>noaa</strong></font></td>
	<td WIDTH="89%">integer noaa(ndim) is backup of noa</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nomm</strong></font></td>
	<td WIDTH="89%">integer nomm(ndim) is backup of nom</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bNt</strong></font></td>
	<td WIDTH="89%">integer bNt(100), where bNt(i) indicates how many moves of type 'i' have been tried. For example, bNt(2) indicates the number of two-bond blocks moves, and bNt(27) indicates the number of rotation moves of the C-terminal</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bNNt</strong></font></td>
	<td WIDTH="89%">integer bNNt(100), where bNt(i) indicates how many moves of any type have been tried for replica 'i'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>oo</strong></font></td>
	<td WIDTH="89%">integer oo(ndim), where oo(i) is index defining the CA bond-vector joining 'i'  and 'i+1' right before a move that changed this bond moving 'i', ie., old index</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ox</strong></font></td>
	<td WIDTH="89%">real ox(ndim), where ox(i) is the x-coordinate of position of CA atom 'i' right before moving 'i', ie., old position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>oy</strong></font></td>
	<td WIDTH="89%">real oy(ndim), where oy(i) is the y-coordinate of position of CA atom 'i' right before moving 'i', ie., old position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>oz</strong></font></td>
	<td WIDTH="89%">real oz(ndim), where oz(i) is the z-coordinate of position of CA atom 'i' right before moving 'i', ie., old position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nx</strong></font></td>
	<td WIDTH="89%">real nx(ndim), where nx(i) will the x-coordinate of position of CA atom 'i' if the proposed move is accepted, ie., new position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ny</strong></font></td>
	<td WIDTH="89%">real ny(ndim), where ny(i) will the y-coordinate of position of CA atom 'i' if the proposed move is accepted, ie., new position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nz</strong></font></td>
	<td WIDTH="89%">real nz(ndim), where nz(i) will the z-coordinate of position of CA atom 'i' if the proposed move is accepted, ie., new position</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nn</strong></font></td>
	<td WIDTH="89%">integer nn(ndim), where n(i) is CA bond-vector index joining 'i' and 'i+1' for a proposed new bond (through the proposition of a particular move)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aranzy</strong></font></td>
	<td WIDTH="89%">function aranzy returns a random number between one and zero.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dinew</strong></font></td>
	<td WIDTH="89%">real dinew analogous to conew but for distance restraints. OBSOLETE</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>diold</strong></font></td>
	<td WIDTH="89%">real diold analogous to coold but for distance restraints. OBSOLETE</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>didev</strong></font></td>
	<td WIDTH="89%">real didev analogous to codev but for distance restraints. OBSOLETE</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>didevsum</strong></font></td>
	<td WIDTH="89%">real didevsum analogous to codevsum but for distance restraints. OBSOLETE</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dilim</strong></font></td>
	<td WIDTH="89%">real dilim analogous to colim but for distance restraints. OBSOLETE</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ESHORT4a</strong></font></td>
	<td WIDTH="89%">double ESHORT4a is the net deviation of SG-SG distances from the cut-off distances when the contact restraints are present.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>conew</strong></font></td>
	<td WIDTH="89%">real conew is the sum of the differences between distance and cut-off distance for SG-SG contact restraints for a conformation after the move</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>coold</strong></font></td>
	<td WIDTH="89%">real coold is the sum of the differences between distance and cut-off distance for SG-SG contact restraints for a conformation before the move</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>a_rest</strong></font></td>
	<td WIDTH="89%">real a_rest is factor by which me reset the maximum temperature atemp2. a_rest is the square root of the linear density of contact restraints (Ncom/Lch). Thus, a_rest>1 will increase atemp2 (and viceversa)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB3</strong></font></td>
	<td WIDTH="89%">real EHB3 ???????????</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB2</strong></font></td>
	<td WIDTH="89%">real EHB2 ???????????</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB5a</strong></font></td>
	<td WIDTH="89%">real EHB5a is the sum of the energies due to helical-type hydrogen bonds.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB5b</strong></font></td>
	<td WIDTH="89%">real EHB5b is the sum of the energies due to beta-sheet-type hydrogen bonds.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB4</strong></font></td>
	<td WIDTH="89%">real EHB1a is the sum of the energies due to the 1/r excluded volume for all CA-CA pairs that are in a contact of type beta-parallel</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB1a</strong></font></td>
	<td WIDTH="89%">real EHB1a is the sum of the energies due to the 1/r excluded volume for all CA-CA pairs that are in a contact that is not of type beta-parallel</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB1</strong></font></td>
	<td WIDTH="89%">real EHB1 is the sum of the energies due to the 1/r excluded volume for all CA-SG pairs</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB1c</strong></font></td>
	<td WIDTH="89%">real EHB1c is the sum of the energies due to the 1/r excluded volume for all SG-SG pairs</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nom</strong></font></td>
	<td WIDTH="89%">integer nom(ndim), where nom(i) is the number of contacts of type medium that residue 'i' is involved in. A contact between 'i' and 'j' is termed medium if bisector of 'i' and bisector of 'j' have a projection in the range [-1/2,1/2]</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nop</strong></font></td>
	<td WIDTH="89%">integer nop(ndim), where nop(i) is the number of contacts of type beta-parallel that residue 'i' is involved in. A contact between 'i' and 'j' is termed parallel if bisector of 'i' and bisector of 'j' have a projection bigger than 1/2</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>noa</strong></font></td>
	<td WIDTH="89%">integer noa(ndim), where noa(i) is the number of contacts of type beta-antiparallel that residue 'i' is involved in. A contact between 'i' and 'j' is termed parallel if bisector of 'i' and bisector of 'j' have a projection smaller than -1/2</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ISTAT</strong></font></td>
	<td WIDTH="89%">integer ISTAT can take the values -1,1,10. istat=-1 marks calculations pertaining to Eold. istat=1 marks calculations pertaining to Enew. istat=10 marks calculations pertaining to penalization realated to broken restraints</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>sumct</strong></font></td>
	<td WIDTH="89%">integer sumct is total number of contacts</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>sumcto</strong></font></td>
	<td WIDTH="89%">integer sumcto ????????</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>icnt</strong></font></td>
	<td WIDTH="89%">integer icnt is contact order</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>icnto</strong></font></td>
	<td WIDTH="89%">integer icnto  ????????</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>egx</strong></font></td>
	<td WIDTH="89%">real egx(ndim), where egx(i) is x-coordinate of SG of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>egy</strong></font></td>
	<td WIDTH="89%">real egy(ndim), where egy(i) is y-coordinate of SG of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>egz</strong></font></td>
	<td WIDTH="89%">real egz(ndim), where egz(i) is z-coordinate of SG of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ex</strong></font></td>
	<td WIDTH="89%">real ex(ndim), where ex(i) is x-coordinate of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ey</strong></font></td>
	<td WIDTH="89%">real ey(ndim), where ey(i) is y-coordinate of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ez</strong></font></td>
	<td WIDTH="89%">real ez(ndim), where ez(i) is z-coordinate of residue 'i' belonging to a frozen fragment. Remember frozen fragments have off-lattice coordinates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ica</strong></font></td>
	<td WIDTH="89%">integer ica(ndim), where ica(i) is the CA-CA bond vector index that defines the CA-CA bond vector joining residue 'i' and 'i+1'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>x</strong></font></td>
	<td WIDTH="89%">integer x(ndim), where x(i) is the x-coordinate of residue 'i' of the current replica being simulated</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>y</strong></font></td>
	<td WIDTH="89%">integer y(ndim), where y(i) is the y-coordinate of residue 'i' of the current replica being simulated</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>z</strong></font></td>
	<td WIDTH="89%">integer z(ndim), where z(i) is the z-coordinate of residue 'i' of the current replica being simulated</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>itemp</strong></font></td>
	<td WIDTH="89%">integer itemp is the index of the current replica being simulated</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>icycle</strong></font></td>
	<td WIDTH="89%">integer icycle is the running index for replica-swap events</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>amcheck_dis</strong></font></td>
	<td WIDTH="89%">real amcheck_dis is excluded volume (in Agnstrom units).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>q</strong></font></td>
	<td WIDTH="89%">real q(0:1000). where q(i)==1 iff the template structure currently being read provides coordinates for residue 'i'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cx0</strong></font></td>
	<td WIDTH="89%">real cx0(0:1000), where cx0(i) is x-coordinate of residue 'i' for the template structure currently being read (see subroutine read_initial_from_temp).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cy0</strong></font></td>
	<td WIDTH="89%">real cy0(0:1000), where cy0(i) is y-coordinate of residue 'i' for the template structure currently being read (see subroutine read_initial_from_temp).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cz0</strong></font></td>
	<td WIDTH="89%">real cz0(0:1000), where cz0(i) is z-coordinate of residue 'i' for the template structure currently being read (see subroutine read_initial_from_temp).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>L_ali</strong></font></td>
	<td WIDTH="89%">integer L_ali is the number of residues that have coordinates in the current template structure being read. Allways L_ali<=Lch</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>n_thr</strong></font></td>
	<td WIDTH="89%">integer n_thr is the number of templates in file init.dat.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>mv</strong></font></td>
	<td WIDTH="89%">integer mv(ndim), where mv(i)=1 iff residue 'i' is moveable.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras6</strong></font></td>
	<td WIDTH="89%">integer ras6(ndim), where ras6(i) indicates the position along the sequence where the moveable, six-residue block with block index 'i' starts. Index 'i' runs from one to the number of moveable, six-residue blocks, i.e. nfl6. We do not use ras6(i) with i>nfl6.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras5</strong></font></td>
	<td WIDTH="89%">integer ras5(ndim), where ras5(i) indicates the position along the sequence where the moveable, five-residue block with block index 'i' starts. Index 'i' runs from one to the number of moveable, five-residue blocks, i.e. nfl5. We do not use ras5(i) with i>nfl5.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras4</strong></font></td>
	<td WIDTH="89%">integer ras4(ndim), where ras4(i) indicates the position along the sequence where the moveable, four-residue block with block index 'i' starts. Index 'i' runs from one to the number of moveable, four-residue blocks, i.e. nfl4. We do not use ras4(i) with i>nfl4.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras3</strong></font></td>
	<td WIDTH="89%">integer ras3(ndim), where ras3(i) indicates the position along the sequence where the moveable, thre-residue block with block index 'i' starts. Index 'i' runs from one to the number of moveable, three-residue blocks, i.e. nfl3. We do not use (i) with i>nfl3.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras2</strong></font></td>
	<td WIDTH="89%">integer ras2(ndim), where ras2(i) indicates the position along the sequence where the moveable, two-bond block with block index 'i' starts. Index 'i' runs from one to the number of moveable, two-bond blocks, i.e. nfl2. We do not use ras2(i) with i>nfl2.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ras</strong></font></td>
	<td WIDTH="89%">integer ras(ndim), where ras(i)==i for a normal run (no frozen segments).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aybet</strong></font></td>
	<td WIDTH="89%">aybet(0:19),  where aybet(i) is the y-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by ayalf(i) ). Rotamer corresponds to average position when amino acid is within a beta-strand.  The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>azbet</strong></font></td>
	<td WIDTH="89%">azbet(0:19),  where azbet(i) is the z-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by azalf(i) ). Rotamer corresponds to average position when amino acid is within a beta-strand.  The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>axbet</strong></font></td>
	<td WIDTH="89%">axbet(0:19),  where axbet(i) is the x-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by axalf(i) ). Rotamer corresponds to average position when amino acid is within a beta-strand.  The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})gx</td>
</tr><tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfr</strong></font></td>
	<td WIDTH="89%">integer nfr is number of frozen fragments.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl</strong></font></td>
	<td WIDTH="89%">integer nfl is number of flexible fragments.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl2</strong></font></td>
	<td WIDTH="89%">integer nfl2 is number of two-bond blocks that can be moved.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl3</strong></font></td>
	<td WIDTH="89%">integer nfl3 is number of three-bond blocks that can be moved.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl4</strong></font></td>
	<td WIDTH="89%">integer nfl4 is number of four-bond blocks that can be moved.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl5</strong></font></td>
	<td WIDTH="89%">integer nfl5 is number of five-bond blocks that can be moved.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nfl6</strong></font></td>
	<td WIDTH="89%">integer nfl6 is number of six-bond blocks that can be moved.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>exc</strong></font></td>
	<td WIDTH="89%">integer exc is the square of the excluded diameter between two CA's.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>xrep</strong></font></td>
	<td WIDTH="89%">integer xrep(ndim,nvec), where xrep(i,k) is the x-component of the position of amino acid 'i' for replica 'k'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>n_repf</strong></font></td>
	<td WIDTH="89%">integer n_repf is the number of output replicas. Sometimes we are not interested to record results of the hottest replicas, so that n_repf<=N_rep.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>v22</strong></font></td>
	<td WIDTH="89%">integer v22(nvec,nvec,46), where v22(i,j,k) is the CA-CA bond vector index of one two vectors (the other being v21(i,j,k) ) whose sum gives (vx(i)+vx(j),vy(i)+vy(j),vz(i)+vz(j)). The 'k' index runs from one to the number of ways one can add to CA-CA vectors and obtain vector (vx(i)+vx(j),vy(i)+vy(j),vz(i)+vz(j))(this maximum number is Np2(i,j) ). It is implied that the angle between vectors v22(i,j,k) and v21(i,j,k) is in [65,165].</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>v21</strong></font></td>
	<td WIDTH="89%">integer v21(nvec,nvec,46), where v21(i,j,k) is the CA-CA bond vector index of one two vectors (the other being v22(i,j,k) ) whose sum gives (vx(i)+vx(j),vy(i)+vy(j),vz(i)+vz(j)). The 'k' index runs from one to the number of ways one can add to CA-CA vectors and obtain vector (vx(i)+vx(j),vy(i)+vy(j),vz(i)+vz(j))(this maximum number is Np2(i,j) ). It is implied that the angle between vectors v21(i,j,k) and v22(i,j,k) is in [65,165].</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Np2</strong></font></td>
	<td WIDTH="89%">integer Np2(nvec,nvec), where Np2(i,j) is the number of ways we can obtain vector (vx(i)+vx(j),vy(i)+vy(j),vz(i)+vz(j)) by summing two CA-CA bond vectors. It is implied that the angle between the two CA-CA bond vectors is in the [65,165] range.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>w22</strong></font></td>
	<td WIDTH="89%">integer w22(-10:10,-10:10,-10:10,46), where w22(i,j,k,l) is the index of one of the two CA-CA bond vectors (the other being w21(i,j,k,l) ) whose sum gives vector with components (i,j,k). 'l' is an index that runs from one to the number of all possible sums of two CA-CA bond vectors  giving vector (i,j,k) (this maximum number is Nw(i,j,k) ). An extra condition is that the two CA-CA bond vectors being added must make an angle in the [65,165] range.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>w21</strong></font></td>
	<td WIDTH="89%">integer w21(-10:10,-10:10,-10:10,46), where w21(i,j,k,l) is the index of one of the two CA-CA bond vectors (the other being w22(i,j,k,l) ) whose sum gives vector with components (i,j,k). 'l' is an index that runs from one to the number of all possible sums of two CA-CA bond vectors  giving vector (i,j,k) (this maximum number is Nw(i,j,k) ). An extra condition is that the two CA-CA bond vectors being added must make an angle in the [65,165] range.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Nw</strong></font></td>
	<td WIDTH="89%">integer Nw(-10:10,-10:10,-10:10), where Nw(i,j,k) is the number of ways one can sum two CA-CA bond vectors whose angle is in between [65&deg;,165&deg;], and the result is a vector with components (i,j,k).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acorder</strong></font></td>
	<td WIDTH="89%">float acorder is the predicted contact order. The value depends on the predicted secondary structure content, besides de sequence lenght.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>frgb</strong></font></td>
	<td WIDTH="89%">float frgb(ndim), where frgb(i)=19.1/0.87 (if amino acids 'i'+1 to 'i'+5 have all &beta;-strand propensity (and zero otherwise). An additional condition is that neither 'i' nor 'i'+6 have helical propensity. This is a local bias towards certain type of secondary structure.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>frga</strong></font></td>
	<td WIDTH="89%">float frga(ndim), where frga(i)=10.5/0.87 (distance in lattice units between eight helical residues) if amino acids 'i' to 'i'+7 have all &alpha;-helical propensity (and zero otherwise). This is a local bias towards certain type of secondary structure.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>gz</strong></font></td>
	<td WIDTH="89%">float gz(nvec,nvec,0:19), where gz(i,j,k) is the z-component of the SG-coordinate (in lattice units) with respect to its CA for amino acid of type 'k'. 'i' is the CA-CA bond vector that goes from the previous CA to the current CA. 'j' is the bond vector from current CA to next CA.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>gy</strong></font></td>
	<td WIDTH="89%">float gy(nvec,nvec,0:19), where gy(i,j,k) is the y-component of the SG-coordinate (in lattice units) with respect to its CA for amino acid of type 'k'. 'i' is the CA-CA bond vector that goes from the previous CA to the current CA. 'j' is the bond vector from current CA to next CA.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>gx</strong></font></td>
	<td WIDTH="89%">float gx(nvec,nvec,0:19), where gx(i,j,k) is the x-component of the SG-coordinate (in lattice units) with respect to its CA for amino acid of type 'k'. 'i' is the CA-CA bond vector that goes from the previous CA to the current CA. 'j' is the bond vector from current CA to next CA.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>hby</strong></font></td>
	<td WIDTH="89%">float hby(nvec,nvec) is the y-component of the unit vector from the vector product of CA-CA bond vectors with indexes 'i' and 'j' (hby(i,j)= (vz(i)vx(j)-vz(j)vx(i))/|vz(i)vx(j)-vz(j)vx(i)| ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>hbz</strong></font></td>
	<td WIDTH="89%">float hbz(nvec,nvec) is the z-component of the unit vector from the vector product of CA-CA bond vectors with indexes 'i' and 'j' (hbz(i,j)= (vx(i)vy(j)-vx(j)vy(i))/|vx(i)vy(j)-vx(j)vy(i)| )</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>hbx</strong></font></td>
	<td WIDTH="89%">float hbx(nvec,nvec) is the x-component of the unit vector from the vector product of CA-CA bond vectors with indexes 'i' and 'j' (hbx(i,j)= (vy(i)vz(j)-vy(j)vz(i))/|vy(i)vz(j)-vy(j)vz(i)| )</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>caz</strong></font></td>
	<td WIDTH="89%">float caz(nvec,nvec), where caz(i,j) is the z-component of the unit bisector vector of CA-CA bond vectors with indexes 'i' and 'i' ( caz(i,j)=(vz(i)-vz(j))/|vz(i)-vz(j)| ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cay</strong></font></td>
	<td WIDTH="89%">float cay(nvec,nvec), where cay(i,j) is the y-component of the unit bisector vector of CA-CA bond vectors with indexes 'i' and 'i' ( cay(i,j)=(vy(i)-vy(j))/|vy(i)-vy(j)| ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cax</strong></font></td>
	<td WIDTH="89%">float cax(nvec,nvec), where cax(i,j) is the x-component of the unit bisector vector of CA-CA bond vectors with indexes 'i' and 'i' ( cax(i,j)=(vx(i)-vx(j))/|vx(i)-vx(j)| ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ayalf</strong></font></td>
	<td WIDTH="89%">ayalf(0:19),  where ayalf(i) is the y-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by aybet(i) ).  The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>azalf</strong></font></td>
	<td WIDTH="89%">azalf(0:19),  where azalf(i) is the z-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by azbet(i) ).  The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>axalf</strong></font></td>
	<td WIDTH="89%">axalf(0:19),  where axalf(i) is the x-coordinate of one of the rotamer positions of the SG group of amino acid of type 'i' with respect to its CA (the other position given by axbet(i) ). The the vectors that make up the vector base used to derive the coordinates is (1)the normalized summ of (CA_{i-1}--CA_i)+(CA_i--CA_{i=1}); (2) the normalized cross product (CA_{i-1}--CA_i) x (CA_i--CA_{i=1}); and (3) The normalized diference of (CA_{i-1}--CA_i)-(CA_i--CA_{i=1})</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>max_m12</strong></font></td>
	<td WIDTH="89%">integer max_m12 is the maximun of all m12(i).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>u2</strong></font></td>
	<td WIDTH="89%">integer u2(nvec,100), where u2(i,j) is the CA-CA bond vector index of one of two CA-CA bond vectors (the other is u1(i,j) ) whose sum turns out to be the CA-CA bond vector with index 'i'. 'j' is an index that runs from 1 to m12(i).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>u1</strong></font></td>
	<td WIDTH="89%">integer u1(nvec,100), where u1(i,j) is the CA-CA bond vector index of one of two CA-CA bond vectors (the other is u2(i,j) ) whose sum turns out to be the CA-CA bond vector with index 'i'. 'j' is an index that runs from 1 to m12(i).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>m12</strong></font></td>
	<td WIDTH="89%">integer m12(nvec), where m12(i) is the number of times the sum of two CA-CA bond vectors turns out to be the CA-CA bond vector with index 'i'. If there are no such occurrences, then m12(i)=0.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>u21</strong></font></td>
	<td WIDTH="89%">integer u21(nvec,nvec), where u21(i,j) is the CA-CA bond vector index of the vector which is the sum of CA-CA bond vectors with indexes 'i' and 'i' ( vx( u21(i,j) ) = vx(i) + vx(j), vy... )</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>goodc</strong></font></td>
	<td WIDTH="89%">logical goodc(nvec,nvec), where goodc(i,j) is 'true' if the angle between CA-CA bond vector 'i' and CA-CA bond vector 'j' is in the [65&deg;,165&deg;] range.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>angle</strong></font></td>
	<td WIDTH="89%">float angle(nvec,nvec), where angle(i,j) is the angle between CA-CA bond vector 'i' and CA-CA bond vector 'j' (in degrees).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aaa</strong></font></td>
	<td WIDTH="89%">float aaa is the average CA-CA bond vector.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>vector</strong></font></td>
	<td WIDTH="89%">integer vector(-5:5,-5:5,-5:5), where vector(i,k,l) is the CA-CA bond vector number with coordinates (i,k,l) (the highest vector number is 'nwmax').</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nwmax</strong></font></td>
	<td WIDTH="89%">integer nwmax is the number of possible CA-CA bond vectors, al igual que nvec.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>vx</strong></font></td>
	<td WIDTH="89%">integer vx(nvec), where vx(i) is the x-component of one of the possible CA-CA bond vectors.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>vy</strong></font></td>
	<td WIDTH="89%">integer vy(nvec), where vy(i) is the y-component of one of the possible CA-CA bond vectors.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>vz</strong></font></td>
	<td WIDTH="89%">integer vz(nvec), where vz(i) is the z-component of one of the possible CA-CA bond vectors.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHBIJ</strong></font></td>
	<td WIDTH="89%">integer EHBIJ(ndim,ndim), where EHBIJ(j,i) is weight-strength of a backbone hydrogen bond between amino acids 'i' and 'j'.  EHBIJ(j,i)=1.5 if there's an increase probability that both amino acids will be part of an &alpha;-helix or a &beta;-sheet. EHBIJ(j,i)=1.0 otherwise.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs_rep</strong></font></td>
	<td WIDTH="89%">float aTTs_rep(nrep), where aTTs_rep(i) is</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs_rep</strong></font></td>
	<td WIDTH="89%">float aTs_rep(nrep), where aTs_rep(i) is</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs2</strong></font></td>
	<td WIDTH="89%">float aTTs2 </td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs2</strong></font></td>
	<td WIDTH="89%">float aTs2 </td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs1</strong></font></td>
	<td WIDTH="89%">float aTs1 </td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>atemp2</strong></font></td>
	<td WIDTH="89%">float atemp2 is maximum temperature</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>atemp1</strong></font></td>
	<td WIDTH="89%">float atemp1 is minimum temperature</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aT_rep</strong></font></td>
	<td WIDTH="89%">float aT_rep(nrep), where aT_rep(i) is the temperature of replica 'i'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>er4</strong></font></td>
	<td WIDTH="89%">float er4 is the potential-energy weight associated with deviation of predicted CA-contact restrains.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>er3</strong></font></td>
	<td WIDTH="89%">float er3 is the potential-energy weight associated with SG-contact restrains.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>er1</strong></font></td>
	<td WIDTH="89%">float er1 is the potential-energy weight associated with CA-distance restrains.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dist_CA_cut</strong></font></td>
	<td WIDTH="89%">float dist_CA_cut is the square of the cut-off distance, in lattice units, between two CA's that have a CA-contact restrain. The dist_CA_cut value depends on the difficulty of the target protein ('easy', 'medm' or 'hard).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>distL</strong></font></td>
	<td WIDTH="89%">float distL(ndim,500), where distL(i,j) is the average CA-long-range-distance restrain between amino acid 'i' and amino acid kdisL(i,j), and 'j' is the long-range-distance restrain number of all possible CA-long-range distance restrains in which 'i' participates (the number of which is MdisL(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>kdisL</strong></font></td>
	<td WIDTH="89%">integer kdisL(ndim,500), where kdisL(i,j) is the number of the amino acid whose CA has a long-range-distance restrain with CA of amino acid 'i', and 'j' is the long-range-distance restrain number of all possible CA-long-range distance restrains in which 'i' participates (the number of which is MdisL(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>MdisL</strong></font></td>
	<td WIDTH="89%">integer MdisL(ndim), where MdisL(i) is the number of CA-long-range-distance restrains in which the CA of amino acid 'i' participates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong></strong>NdisL</font></td>
	<td WIDTH="89%">integer NdisL is number of long-range distance-restrains between CA's.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dilim</strong></font></td>
	<td WIDTH="89%">dilim=0.5*Ndis</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dev</strong></font></td>
	<td WIDTH="89%">float dev(ndim,100), where dev(i,j) is the deviation in the distribution of distances between the SG of amino acid 'i' and the CA of amino acid kdist(i,j). 'j' is the CA-distance-restrain number of all possible restrains of this type in which 'i' participates (the number of which is Mdisq(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>dist</strong></font></td>
	<td WIDTH="89%">float dist(ndim,100), where dist(i,j) is the average distance between the CA of amino acid 'i' and the CA of amino acid kdist(i,j). 'j' is the CA-distance-restrain number of all possible restrains of this type in which 'i' participates (the number of which is Mdisq(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>kdis</strong></font></td>
	<td WIDTH="89%">integer kdis(ndim,100), where kdis(i,j) is the amino acid number for amino acid whose CA makes a distance-restrain with the CA of amino acid 'i', and 'j' is the CA-distance-restrain number of all possible , SG-distance-restrains in which 'i' participates (the number of which is Mdisq(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Mdisq</strong></font></td>
	<td WIDTH="89%">integer Mdisq(ndim), where Mdisq(i) is the number of CA-distance-restrains in which amino acid 'i' participates (from <a href="dist.dat">dist.dat</a> ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Ndis</strong></font></td>
	<td WIDTH="89%">integer Ndis is number of input distance-restrains from <a href="dist.dat">dist.dat</a>.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nnc</strong></font></td>
	<td WIDTH="89%">float nnc is average number or SG-restrains per amino acid.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>colim</strong></font></td>
	<td WIDTH="89%">integer colim=1.5*Ncom is a limit for the distance deviations coold, conew and codevsum. If these quantities are bigger than colim, then it means that a great number of contact restraints are broken and for this, we impose further penalization with ESHORT4a</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Kcom</strong></font></td>
	<td WIDTH="89%">integer Kcom(ndim,100), where Kcom(i,j) is the amino acid number of the amino acid whose SG has a contact-restrain with the SG of amino acid 'i', and 'j' is the SG-contact-restrain number, out of all possible  contact-restrains in which 'i' participates (the number of which is Mcom(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>KcomCA</strong></font></td>
	<td WIDTH="89%">integer KcomCA(ndim,100), where KcomCA(i,j) is the amino acid number of the amino acid whose CA has a contact-restrain with the CA of amino acid 'i', and 'j' is the CA-contact-restrain number, out of all possible  contact-restrains in which 'i' participates (the number of which is McomCA(i) ).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Mcom</strong></font></td>
	<td WIDTH="89%">integer Mcom(ndim), where Mcom(i) is the number of SG--contact-restrains in which amino acid 'i' participates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>McomCA</strong></font></td>
	<td WIDTH="89%">integer McomCA(ndim), where McomCA(i) is the number of CA-contact-restrains in which amino acid 'i' participates.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Ncom</strong></font></td>
	<td WIDTH="89%">integer Ncom is the number of SG-contact-restrains that we take into account (equal or less than the number of input contact-restrains).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>NcomCA</strong></font></td>
	<td WIDTH="89%">integer NcomCA is the number of CA-contact-restrains that we take into account (equal or less than the number of input contact-restrains).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aweig</strong></font></td>
	<td WIDTH="89%">aweig(4000,4000), where aweig(i,j) is the weight that we give to contact-restrain between SG's of amino acids 'i' and 'j'. The weight depends on the input confidence level for the contact-restrain and the general difficulty of the target protein (side-note: the leading dimension should be the maximum number of amino acids (Lch), instead of 4000, which is the maximum number of contact-restrains).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aweig</strong></font></td>
	<td WIDTH="89%">aweig(4000,4000), where aweig(i,j) is the weight that we give to contact-restrain between Sg's of amino acids 'i' and 'j'. The weight depends on the input confidence level for the contact-restrain and the general difficulty of the target protein (side-note: the leading dimension should be the maximum number of amino acids (Lch), instead of 4000, which is the maximum number of contact-restrains).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aweigCA</strong></font></td>
	<td WIDTH="89%">aweigCA(4000,4000), where aweigCA(i,j) is the weight that we give to contact-restrain between CA's of amino acids 'i' and 'j'. The weight depends on the input confidence level for the contact-restrain and the general difficulty of the target protein (side-note: the leading dimension should be the maximum number of amino acids (Lch), instead of 4000, which is the maximum number of contact-restrains).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>conf</strong></font></td>
	<td WIDTH="89%">float conf is confidence level (0.0 to 1.0)  of a contact-restrain (the existence of a contact) between two particular CA's.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cut0</strong></font></td>
	<td WIDTH="89%">float cut0 is a reference confidence when assigning weights ('weig' and 'weigCA') to a particular contact-restrain between two CA's or between two SG's. cut0 has a different value if the target protein is classified as 'easy' 'medm' (medium) or 'hard'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cut_min</strong></font></td>
	<td WIDTH="89%">cut_min is the minimun value of the confidence for a contact-restrain between two CA's or two SG's. cut_min has different values depending on the difficulty of the target ('easy', 'medm', 'hard') and also depending on how many input contact-restrains.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>concut</strong></font></td>
	<td WIDTH="89%">concut(0:19,0:19), where concut(i,j) is extended cut-off distance (bigger than cut(i,j) ) in lattice units for a contact between two SG's to be present.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>concut2</strong></font></td>
	<td WIDTH="89%">concut2(0:19,0:19), where concut2(i,j) is the square of concut(i,j).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>izscore</strong></font></td>
	<td WIDTH="89%">izscore=1, 2, or 3 depending on wether the target protein is classified as 'easy', 'medm' (medium) or 'hard'</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cut</strong></font></td>
	<td WIDTH="89%">cut(0:19,0:19), where cut(i,j) is the average contact cut-off (range) between two SG's.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>cut_dev</strong></font></td>
	<td WIDTH="89%">cut_dev(0:19,0:19), where cut_dev(i,j) is the deviation in the contact cut-off (range) between two SG's.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>mk_pair3</strong></font></td>
	<td WIDTH="89%">mk_pair3=1 means use files <a href="pair1.dat">pair1.dat</a> and <a href="pair3.dat">pair3.dat</a> (which define symmetric and asymmetric sequence-potentials, respectively).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apar</strong></font></td>
	<td WIDTH="89%">float apar(ndim,ndim), where apar(i,j) is the <b>spherically symmetric, sequence-dependent potential</b> between the SG of amino acid at position "i" and amino acid at position "j". apar(i,j) is initialized to different values depending on different conditions. if file <a href="pair3.dat">pair3.dat</a> exists, then apar(i,j) is a linear combination of apar1(i,j) and apar2(i,j). if variable chuan is very small, then par(i,j) is only apar2(i,j). if file <a href="pair3.dat">pair3.dat</a> does not exists, then apar(i,j) is apar1(i,j).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh1c</strong></font></td>
	<td WIDTH="89%">weigth in the energy term due to pair-wise potential for SC-SC. eh1c=chuan*x (x=1.8,1.0,1.5) or eh1c=1.0</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apar1_max</strong></font></td>
	<td WIDTH="89%">maximum of abs( apar1(i,j) ) for all i,j</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apar2_max</strong></font></td>
	<td WIDTH="89%">maximum of abs( apar2(i,j) ) for all i,j</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apar2</strong></font></td>
	<td WIDTH="89%">float apar2(ndim,ndim) with apar2(i,j) a <strong>spherically symmetric, sequence-dependent potential between amino acids at positions "i" and "j". Input from file <a href="pair1.dat">pair1.dat</a></strong></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apar1</strong></font></td>
	<td WIDTH="89%">float apar1(ndim,ndim) with apar1(i,j) a <strong>spherically symmetric, sequence-dependent potential between amino acids at positions "i" and "j". Input from file <a href="par.dat">par.dat</a></strong></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>vvv</strong></font></td>
	<td WIDTH="89%">vvv(ndim,ndim), with vvv(i,j) marks amino acids "i" and "j" to be checked (=1). vvv(i,j)==-1 indicates 'i' and 'j' belong to same frozen fragment, thus do not check. vvv(i,j)==-2 indicates 'i' and 'j' belong to different frozen fragments and at the beginning of the simulation were too close. Do not check either.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>maxdis2</strong></font></td>
	<td WIDTH="89%">integer maxdis2(ndim), with maxdis2(i) is the maximum distance of walk in i steps.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>contt</strong></font></td>
	<td WIDTH="89%">contt=1.5*float(Lch) is target number of contacts.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>no</strong></font></td>
	<td WIDTH="89%">no=-abs(random), since random number generator aranzy requires an initial negative seed.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apm</strong></font></td>
	<td WIDTH="89%">float apm(ndim,ndim). If we have a sequence-dependent potential for pairwise SG's, then apm(i,j) is a weigthed average <b>potential</b> of apabla (potential common for all sequences) and apba (sequence-dependent potential). The potential applies to two SG's of amino acids at positions "i" and "j" when the vertex vectors or their respective C<sub>&alpha;</sub> are in a mid-position (neither parallel, nor anti-parallel).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>app</strong></font></td>
	<td WIDTH="89%">float app(ndim,ndim). If we have a sequence-dependent potential for pairwise SG's, then app(i,j) is a weigthed average <b>potential</b> of apabla (potential common for all sequences) and apba (sequence-dependent potential). The potential applies to two SG's of amino acids at positions "i" and "j" when the vertex vectors or their respective C<sub>&alpha;</sub> are parallel</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apa</strong></font></td>
	<td WIDTH="89%">float apa(ndim,ndim). If we have a sequence-dependent potential for pairwise SG's, then apa(i,j) is a weigthed average <b>potential</b> of apabla (potential common for all sequences) and apba (sequence-dependent potential). The potential applies to two SG's of amino acids at positions "i" and "j" when the vertex vectors or their respective C<sub>&alpha;</sub> are anti-parallel</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>fract_pair3</strong></font></td>
	<td WIDTH="89%">fract_pair3=0.7 (see apa, apm, or app).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apbp</strong></font></td>
	<td WIDTH="89%">float apbp(ndim,ndim), with apbp(i,j) <b>sequence-dependent potential</b> for a contact between SG's of amino acid type "i" and amino acid type "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apbm</strong></font></td>
	<td WIDTH="89%">float apbm(ndim,ndim), with apbm(i,j) <b>sequence-dependent potential</b> for a contact between SG's of amino acid type "i" and amino acid type "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are anti-parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apba</strong></font></td>
	<td WIDTH="89%">float apba(ndim,ndim), with apba(i,j) <b>sequence-dependent potential</b> for a contact between SG's of amino acid type "i" and amino acid type "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>i_pair3</strong></font></td>
	<td WIDTH="89%">integer i_pair3=1 if we read file <a href="pair3.dat">pair3.dat</a>, and -1 if we don't read it.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ala</strong></font></td>
	<td WIDTH="89%">float ala(0:19,0:19), with ala(i,j) the square of the cutoff contact <b>distance</b> between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the bisector vectors of their respective C<sub>&alpha;</sub>'s are anti-parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>alm</strong></font></td>
	<td WIDTH="89%">float alm(0:19,0:19), with alm(i,j) the square of the cutoff contact <b>distance</b> between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the bisector vectors of their respective C<sub>&alpha;</sub>'s are in a mid-position (neither parallel, nor anti-parallel).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>alp</strong></font></td>
	<td WIDTH="89%">float alp(0:19,0:19), with alp(i,j) the square of the cutoff contact <b>distance</b> between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the bisector vectors of their respective C<sub>&alpha;</sub>'s are parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ash_min</strong></font></td> 
	<td WIDTH="89%">ratio between minimal and average pairwise distance between two interacting SG's, with interactions given by file <a href="quasi3.comm">quasi3.comm</a></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ash_max</strong></font></td>
	<td WIDTH="89%">ratio between maximal and average pairwise distance between two interacting SG's, with interactions given by file <a href="quasi3.comm">quasi3.comm</a> </td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ash</strong></font></td>
	<td WIDTH="89%">ash = (ash_max-ash_min)/2.0, ie, half the width of allowed contact distances between two SG's, in units of the average SG contact distance.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>arlm</strong></font></td>
	<td WIDTH="89%">float arlm(0:19,0:19). When initialized, arlm(i,j) is average <b>distance</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are in a mid-position (neither parallel, nor antiparallel).  After alm(i,j) is initialized, arlm(i,j) becomes the square of the hard-core contact distance between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the vertex vectors of their respective C<sub>&alpha;</sub>'s are in a mid-position (neither parallel, nor antiparallel).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>arlp</strong></font></td>
	<td WIDTH="89%">float arlp(0:19,0:19). When initialized, arlp(i,j) is average <b>distance</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are parallel. After alp(i,j) is initialized, arlp(i,j) becomes the square of the hard-core contact distance between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the vertex vectors of their respective C<sub>&alpha;</sub>'s are parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>arla</strong></font></td>
	<td WIDTH="89%">float arla(0:19,0:19). When initialized, arla(i,j) is average <b>distance</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are anti-parallel. After ala(i,j) is initialized, arla(i,j) becomes the square of the hard-core contact distance between SG's of amino acid type "i" and amino acid type "j", in lattice units, when the vertex vectors of their respective C<sub>&alpha;</sub>'s are anti-parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apablp</strong></font></td>
	<td WIDTH="89%">float apablp(0:19,0:19) with apablp(i,j) <b>potential</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apablm</strong></font></td>
	<td WIDTH="89%">float apablm(0:19,0:19) with apablm(i,j) <b>potential</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are in a mid-position (neither parallel, nor antiparallel).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>apabla</strong></font></td>
	<td WIDTH="89%">float apabla(0:19,0:19) with apabla(i,j) <b>potential</b> between two SG's of amino acids with types "i" and "j" when the vertex vectors of their respective C<sub>&alpha;</sub>'s are anti-parallel.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acops</strong></font></td>
	<td WIDTH="89%">float acops(ndim,16), where acops(i,k) is the minimum of either zero or a weighted linear combination of bsr over the k-1, k and k+1 bins (bsr is a potential between the C<sub>&alpha;</sub> of amino acid at position "i" and the C<sub>&alpha;</sub> of amino acid at position "i+4".</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>jbin</strong></font></td>
	<td WIDTH="89%">integer jbin(0:500), where jbin(i) translate the distance square in lattice units (i=x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>) to distance in Angstroms, but only the integer part. This distance is also the bin number between 1 and 16.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bsr</strong></font></td>
	<td WIDTH="89%">float bsr(ndim,16), where bsr(i,k) is the potential between C<sub>&alpha;</sub> of amino acid at position "i" with C<sub>&alpha;</sub> of amino acid at position "i+4", separated by distance "k", where k is a bin number representative of certain range of distances. If "i" predicted to adopt a helix-like conformation, then we bsr(i,k) will be most attractive for distances "k" typical of helix. Same if "i" predicted to adopt a strand-like conformation.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bsre</strong></font></td>
	<td WIDTH="89%">same format as bsrr, but we favor longer distances, more typical of a strand conformation at least from amino acid at position l and amino acid at l+4.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bsrh</strong></font></td>
	<td WIDTH="89%">same format as bsrr, but we favor shorter distances, more typical of a helical conformation at least from amino acid at position l and amino acid at l+4.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bsrr</strong></font></td>
	<td WIDTH="89%">float bsrr(0:19,0:19,16), where bsrr(i,j,k) is the potential between C<sub>&alpha;</sub>'s of amino acid of type "i" and amino acid of type "j" separated by 4 amino acids along the sequence, and separated by a distance "k". k takes values from 1 to 16, which represent bin numbers for distances between zero and some cut-off distance</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ibin</strong></font></td>
	<td WIDTH="89%">integer ibin(-300:300), where ibin(i) translate the distance square in lattice units (i=x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>) to distance in Angstroms, but only the integer part. This distance is also the bin number between 1 and 12.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>asr</strong></font></td>
	<td WIDTH="89%">float asr(ndim,-12:12), where asr(i,k) is the potential energy between C<sub>&alpha;</sub> of amino acid at position "i" and C<sub>&alpha;</sub> of amino acid at "i+4", separated by a combination of distance and chirality "k".</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>asre</strong></font></td>
	<td WIDTH="89%">same as asrr but longer distances are preferred over asrr, to emulate preference for strand content.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>asrh</strong></font></td>>
	<td WIDTH="89%">same as asrr but shorter distances are preferred over asrr, to emulate preference for helix content.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>asrr</strong></font></td>
	<td WIDTH="89%">float asrr(0:19,0:19,-12:12), where asrr(i,j,k) is the potential between C<sub>&alpha;</sub> of amino acid of type "i" and C<sub>&alpha;</sub> of amino acid of type "j" separated by three amino aids along the sequence, and separated by a combination of distance and chirality included in "k". k takes 25 different values (probably negative values indicate negative chirality).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>csr</strong></font></td>
	<td WIDTH="89%">float csr(ndim,2), where csr(i,k) is the potential energy between C<sub>&alpha;</sub> of amino acid at position "i" and C<sub>&alpha;</sub> of amino acid at position "i+2" when separated by distance "k". k takes two values depending on whether the sequence stretch is compact (k=1) or expanded (k=2).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>csre</strong></font></td>
	<td WIDTH="89%">float csre(0:19,0:19,2) where csre(i,j,k) is potential between amino acids of type "i" and "j" separated in sequence by 2 other amino acids, and separated in distance by "k". k takes two values depending on whether the sequence stretch is compact (k=1) or expanded (k=2).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>envir</strong></font></td>
	<td WIDTH="89%">float envir(0:15,0:15,0:15,0:19,4) potential that specifies the contact environment of an amino acid of a given residue type. envir(ia,im,ip,i,j) indicates the energy given to an amino acid of residue type "i" when surrounded by amino acids that make "ia" antiparallel contacts, "im" orthogonal contacts, and "ip" parallel contacts. by  All envir(0:15,0:15,0:15,0:19,4) elements are initialized to 2.0. </td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acrit</strong></font></td>
	<td WIDTH="89%">expected gyration radius</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eonehw</strong></font></td>
	<td WIDTH="89%">float eonehw(0:19) hydrophilic potential for Sg, positive for hydrophilic residue</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eonekd</strong></font></td>
	<td WIDTH="89%">float eonehw(0:19) hydrophobic potential for Sg, positive for hydrophobic residue</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Lch2</strong></font></td>
	<td WIDTH="89%">Lch2=Lch-2, ie, sequence minus the two end points.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Lch1</strong></font></td>
	<td WIDTH="89%">Lch1=Lch-1, ie, sequence minus the C-terminal residue.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>SEC</strong></font></td>
	<td WIDTH="89%">integer array with ndim elements, each element is the secondary structure identifier for the amino acid (1:coil 2:helix 4:strand)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>sequ</strong></font></td>
	<td WIDTH="89%">string array with ndim elements, each element is the three letter code amino acid.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>icg</strong></font></td>
	<td WIDTH="89%">integer array with ndim elements, each element is the charge of the residue (-1 or 0 or 1).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>seq</strong></font></td>
	<td WIDTH="89%">integer array whith Lch elements, each element is the amino acid type identifier (given by the index of array aa).</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Lch</strong></font></td>
	<td WIDTH="89%">number of amino acids (length) of the protein.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aa</strong></font></td>
	<td WIDTH="89%">integer array from -1 to 20 where every number corresponds to a three letter amino acid code (alphabetically sorted). -1 is reserved for backbone 'BCK' and 20 is reserved for 'CYX'.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>protein</strong></font></td>
	<td WIDTH="89%">PDB identifier of the protein.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>nvec</strong></font></td>
	<td WIDTH="89%">number of CA-CA bond vectors, al igual que nwmax</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ndim</strong></font></td>
	<td WIDTH="89%">maximum number of amino acids.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bh2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>hsum</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acut_bb</strong></font></td>
	<td WIDTH="89%">float acut_bb is the minimal value of the dot product of two donor/aceptor vectors. The value listed in in.dd is 0.45, corresponding to 63degrees</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acut_cc</strong></font></td>
	<td WIDTH="89%">float acut_cc is minimal dot product between bisector vectors of CA_i and CA_{i+3} when in a helix conformation. The value listed in in.dd is 0.1, corresponding to 85degrees</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acut_hh</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>acut_vv</strong></font></td>
	<td WIDTH="89%">float acut_vv is the minimal dot product between bond vector (i-1,i) and (i-2,i+3) when forming in a helix conformation. Listed value in in.dd is 0.0</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>angle0</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTs2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>aTTs2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bcut_bb</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bcut_cc</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bcut_hh</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>bcut_vv</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>chuan</strong></font></td>
	<td WIDTH="89%">Relative scale of threading-derived energy terms with respect to ab initio energy terms</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Cr2a</strong></font></td>
	<td WIDTH="89%">float Cr2a square of maximum distance between CAi and CA_{i+3} when in a helix conformation. Listed value in in.dd is 48, which traslates to the square of 6&Aring</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Cr2b</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>d_xyz0</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh1a</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh1b</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh3</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh4</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh5a</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>eh5b</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>en1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>en2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>en3</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>er6</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es3</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es3a</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es3b</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es3c</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es4</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es5</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>es6</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>exc1</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>exc2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>exc</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h2</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h3d</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h3s</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h4d</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h4s</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h5d</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h5s</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>h6</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>hend</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>i_thr0</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>L_cut</strong></font></td>
	<td WIDTH="89%">integer L_cut is the size the smallest contiguous block of residues that we allow to read from the template structure being read. That is, we assume the template does not provide coordinates for residues within a segment smaller in size than L_cut.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Mend</strong></font></td>
	<td WIDTH="89%">size (in number of residues) of the putative biggest block of residues that can be moved as a whole either at beginning of the chain or at the end of the chain</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Mend_N</strong></font></td>
	<td WIDTH="89%">size (in number of residues) of the biggeest block of residues that can be moved as a whole at beginning of the chain</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>Mend_C</strong></font></td>
	<td WIDTH="89%">size (in number of residues) of the biggest block of residues that can be moved as a whole at the end of the chain</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>m_initial</strong></font></td>
	<td WIDTH="89%"></td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>ncycles</strong></font></td>
	<td WIDTH="89%">number of replica swaps</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>N_rep</strong></font> </td>
	<td WIDTH="89%">number of replicas.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>phot</strong></font></td>
	<td WIDTH="89%">Number of MC steps in a cycle (between two replica swaps events)</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>random</strong></font></td>
	<td WIDTH="89%">Initial seed for the random algoritm.</td>
</tr>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>switch</strong></font></td>
	<td WIDTH="89%">=1 for simulations with less restricted movements than simulation with switch=2, which is the "template" simulation.</td>
</tr>
</table>
<tr>
	<td WIDTH="11%"><font size="0" color="#FF0000"><strong>EHB1</strong></font></td>
	<td WIDTH="89%">real EHB1 is the sum of the energies due to the 1/r excluded volume for all CA-SG pairs</td>
</tr>
